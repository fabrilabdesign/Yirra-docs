# MCP Platform – End-to-End Setup Guide (k3s + Cloudflare Tunnel/Access)

This guide installs **all MCP servers** onto your k3s cluster on the VM (`192.168.3.103`), fronts them with **Cloudflare Tunnel** and **Cloudflare Access**, and wires both **prod** (read-only) and **staging** (write-enabled where safe). It uses **Kustomize** overlays and **ClusterIP** Services (no Traefik/Ingress for MCP).

Your chosen hostnames:

**Prod**

* `pm-mcp.yirrasystems.com` → `http://pm-mcp.tools.svc.cluster.local:80`
* `fs-mcp.yirrasystems.com` → `http://fs-mcp.tools.svc.cluster.local:80`
* `git-mcp.yirrasystems.com` → `http://git-mcp.tools.svc.cluster.local:80`
* `db-mcp.yirrasystems.com` → `http://db-mcp.tools.svc.cluster.local:80`
* `fetch-mcp.yirrasystems.com` → `http://fetch-mcp.tools.svc.cluster.local:80`
* `stripe-mcp.yirrasystems.com` → `http://stripe-mcp.tools.svc.cluster.local:80`
* `n8n-mcp.addiaire.com` → `http://n8n-mcp.tools.svc.cluster.local:80`

**Staging (single-word subs)**

* `pm-mcpstaging.yirrasystems.com` → `http://pm-mcp.tools-staging.svc.cluster.local:80`
* `fs-mcpstaging.yirrasystems.com` → `http://fs-mcp.tools-staging.svc.cluster.local:80`
* `git-mcpstaging.yirrasystems.com` → `http://git-mcp.tools-staging.svc.cluster.local:80`
* `db-mcpstaging.yirrasystems.com` → `http://db-mcp.tools-staging.svc.cluster.local:80`
* `fetch-mcpstaging.yirrasystems.com` → `http://fetch-mcp.tools-staging.svc.cluster.local:80`
* `stripe-mcpstaging.yirrasystems.com` → `http://stripe-mcp.tools-staging.svc.cluster.local:80`
* `n8n-mcpstaging.addiaire.com` → `http://n8n-mcp.tools-staging.svc.cluster.local:80`

> MCPs are **not** exposed through Traefik. Cloudflare terminates TLS and tunnels traffic directly to the ClusterIP Services.

---

## 0) Prereqs

* k3s running; `kubectl` context points to your cluster.
* Cloudflare account with **Zero Trust**; one **Tunnel** (will use its `*.cfargotunnel.com`).
* Your apps are reachable at:

  * Storefront: `https://yirrasystems.com/`
  * Admin: `https://app.yirrasystems.com/`
  * n8n: `https://flows.addiaire.com/`

---

## 1) Repo layout

Inside your repo’s `MCP_server/`:

```
MCP_server/
  base/
    mcp-server-deployment.yaml
    mcp-server-service.yaml
    kustomization.yaml
  cloudflared/
    serviceaccount.yaml
    secret-credentials.yaml     # paste Tunnel JSON creds here
    configmap.yaml              # hostnames → Services (prod+staging or per-env)
    deployment.yaml
    kustomization.yaml
  overlays/
    prod/
      namespace.yaml            # tools
      pm/                       # pm-mcp (Admin/PM adapter)
        kustomization.yaml
        configmap.tools.yaml
        patch.deployment.yaml
      fs/
        kustomization.yaml
        patch.deployment.yaml
      git/
        kustomization.yaml
        secret.ssh.yaml         # (optional placeholder if you store in Git)
        patch.deployment.yaml
      db/
        kustomization.yaml
        patch.deployment.yaml
      fetch/
        kustomization.yaml
        patch.deployment.yaml
      stripe/
        kustomization.yaml
        patch.deployment.yaml
      n8n/
        kustomization.yaml
        configmap.tools.yaml
        patch.deployment.yaml
      kustomization.yaml        # aggregates all prod MCPs + cloudflared
    staging/
      namespace.yaml            # tools-staging
      ... (same structure as prod; MODE/write toggles + staging secrets)
```

---

## 2) Base manifests (reusable for all MCPs)

`base/mcp-server-deployment.yaml`

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mcp-server
  labels: { app.kubernetes.io/name: mcp-server }
spec:
  replicas: 1
  selector: { matchLabels: { app.kubernetes.io/name: mcp-server } }
  template:
    metadata: { labels: { app.kubernetes.io/name: mcp-server } }
    spec:
      containers:
        - name: server
          image: ghcr.io/example/mcp-placeholder:latest
          imagePullPolicy: IfNotPresent
          ports: [{ name: http, containerPort: 8080 }]
          env:
            - { name: PORT, value: "8080" }
            - { name: MODE, value: "read-only" } # prod default
          readinessProbe: { httpGet: { path: /healthz, port: http }, initialDelaySeconds: 3, periodSeconds: 5 }
          livenessProbe:  { httpGet: { path: /healthz, port: http }, initialDelaySeconds: 10, periodSeconds: 10 }
          resources:
            requests: { cpu: "50m", memory: "64Mi" }
            limits:   { cpu: "500m", memory: "256Mi" }
```

`base/mcp-server-service.yaml`

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mcp-server
  labels: { app.kubernetes.io/name: mcp-server }
spec:
  selector: { app.kubernetes.io/name: mcp-server }
  ports: [{ name: http, port: 80, targetPort: http }]
  type: ClusterIP
```

`base/kustomization.yaml`

```yaml
resources:
  - mcp-server-deployment.yaml
  - mcp-server-service.yaml
```

---

## 3) Cloudflare Tunnel (shared)

**Create a Tunnel** in the Cloudflare dashboard; download the credentials JSON.

`cloudflared/secret-credentials.yaml`

```yaml
apiVersion: v1
kind: Secret
metadata: { name: cloudflared-credentials, namespace: tools }
type: Opaque
stringData:
  credentials.json: |
    { ... the tunnel JSON ... }
```

`cloudflared/configmap.yaml` (one config mapping **all** prod + staging hosts)

```yaml
apiVersion: v1
kind: ConfigMap
metadata: { name: cloudflared-config, namespace: tools }
data:
  config.yaml: |
    tunnel: yirra-mcp
    credentials-file: /etc/cloudflared/credentials/credentials.json
    ingress:
      # PROD
      - hostname: pm-mcp.yirrasystems.com
        service: http://pm-mcp.tools.svc.cluster.local:80
      - hostname: fs-mcp.yirrasystems.com
        service: http://fs-mcp.tools.svc.cluster.local:80
      - hostname: git-mcp.yirrasystems.com
        service: http://git-mcp.tools.svc.cluster.local:80
      - hostname: db-mcp.yirrasystems.com
        service: http://db-mcp.tools.svc.cluster.local:80
      - hostname: fetch-mcp.yirrasystems.com
        service: http://fetch-mcp.tools.svc.cluster.local:80
      - hostname: stripe-mcp.yirrasystems.com
        service: http://stripe-mcp.tools.svc.cluster.local:80
      - hostname: n8n-mcp.addiaire.com
        service: http://n8n-mcp.tools.svc.cluster.local:80

      # STAGING (single-word subs)
      - hostname: pm-mcpstaging.yirrasystems.com
        service: http://pm-mcp.tools-staging.svc.cluster.local:80
      - hostname: fs-mcpstaging.yirrasystems.com
        service: http://fs-mcp.tools-staging.svc.cluster.local:80
      - hostname: git-mcpstaging.yirrasystems.com
        service: http://git-mcp.tools-staging.svc.cluster.local:80
      - hostname: db-mcpstaging.yirrasystems.com
        service: http://db-mcp.tools-staging.svc.cluster.local:80
      - hostname: fetch-mcpstaging.yirrasystems.com
        service: http://fetch-mcp.tools-staging.svc.cluster.local:80
      - hostname: stripe-mcpstaging.yirrasystems.com
        service: http://stripe-mcp.tools-staging.svc.cluster.local:80
      - hostname: n8n-mcpstaging.addiaire.com
        service: http://n8n-mcp.tools-staging.svc.cluster.local:80

      - service: http_status:404
```

`cloudflared/deployment.yaml`

```yaml
apiVersion: apps/v1
kind: Deployment
metadata: { name: cloudflared, namespace: tools }
spec:
  replicas: 1
  selector: { matchLabels: { app: cloudflared } }
  template:
    metadata: { labels: { app: cloudflared } }
    spec:
      serviceAccountName: cloudflared
      containers:
        - name: cloudflared
          image: cloudflare/cloudflared:latest
          args: ["tunnel","--config","/etc/cloudflared/config/config.yaml","run","yirra-mcp"]
          volumeMounts:
            - { name: cfg,   mountPath: /etc/cloudflared/config,       readOnly: true }
            - { name: creds, mountPath: /etc/cloudflared/credentials,  readOnly: true }
      volumes:
        - { name: cfg,   configMap: { name: cloudflared-config } }
        - { name: creds, secret:    { secretName: cloudflared-credentials } }
```

`cloudflared/serviceaccount.yaml`

```yaml
apiVersion: v1
kind: ServiceAccount
metadata: { name: cloudflared, namespace: tools }
```

`cloudflared/kustomization.yaml`

```yaml
resources:
  - serviceaccount.yaml
  - secret-credentials.yaml
  - configmap.yaml
  - deployment.yaml
```

---

## 4) Prod overlays (examples for each MCP)

`overlays/prod/namespace.yaml`

```yaml
apiVersion: v1
kind: Namespace
metadata: { name: tools }
```

### 4.1 PM MCP (Admin/Project-Management adapter)

`overlays/prod/pm/configmap.tools.yaml`

```yaml
apiVersion: v1
kind: ConfigMap
metadata: { name: pm-mcp-tools, namespace: tools }
data:
  tools.json: |
    {
      "baseUrl": "https://app.yirrasystems.com",
      "auth": { "type":"header", "name":"X-Service-Token", "valueFromEnv":"PM_API_TOKEN" },
      "tools": [
        { "name":"list_projects","method":"GET","path":"/api/projects" },
        { "name":"list_tasks","method":"GET","path":"/api/tasks" },
        { "name":"get_task","method":"GET","path":"/api/tasks/{id}","pathParams":["id"] },
        { "name":"ai_plan","method":"POST","path":"/api/ai/plan" }
      ]
    }
```

`overlays/prod/pm/patch.deployment.yaml`

```yaml
apiVersion: apps/v1
kind: Deployment
metadata: { name: pm-mcp, namespace: tools }
spec:
  template:
    metadata: { labels: { app.kubernetes.io/name: pm-mcp } }
    spec:
      containers:
        - name: server
          image: ghcr.io/yourorg/http-proxy-mcp:latest
          env:
            - { name: PORT, value: "8080" }
            - { name: MODE, value: "read-only" }              # prod RO
            - { name: ALLOWLIST, value: "https://app.yirrasystems.com" }
            - { name: PM_API_TOKEN, valueFrom: { secretKeyRef: { name: pm-mcp-secrets, key: PM_API_TOKEN } } }
            - { name: REQUEST_TIMEOUT_MS, value: "10000" }
          volumeMounts:
            - { name: tools, mountPath: /app/tools.json, subPath: tools.json }
      volumes:
        - { name: tools, configMap: { name: pm-mcp-tools } }
```

`overlays/prod/pm/kustomization.yaml`

```yaml
namespace: tools
namePrefix: pm-
resources:
  - ../../../base
patches:
  - target: { kind: Deployment, name: mcp-server }
    path: patch.deployment.yaml
```

> Repeat the same pattern for `fs`, `git`, `db`, `fetch`, `stripe`, `n8n` below—only image/env/volumes differ.

### 4.2 Filesystem MCP (RO in prod)

`overlays/prod/fs/patch.deployment.yaml`

```yaml
apiVersion: apps/v1
kind: Deployment
metadata: { name: fs-mcp, namespace: tools }
spec:
  template:
    metadata: { labels: { app.kubernetes.io/name: fs-mcp } }
    spec:
      containers:
        - name: server
          image: ghcr.io/yourorg/filesystem-mcp:latest
          env:
            - { name: PORT, value: "8080" }
            - { name: MODE, value: "read-only" }
            - { name: ROOTS_JSON, value: "[\"/data/docs\",\"/data/shop\"]" }
            - { name: MAX_BYTES, value: "1048576" }
          volumeMounts:
            - { name: docs, mountPath: /data/docs, readOnly: true }
            - { name: shop, mountPath: /data/shop, readOnly: true }
      volumes:
        - { name: docs, hostPath: { path: /srv/docs, type: Directory } }
        - { name: shop, hostPath: { path: /srv/shop-content, type: Directory } }
```

### 4.3 Git MCP (RO in prod)

`overlays/prod/git/patch.deployment.yaml`

```yaml
apiVersion: apps/v1
kind: Deployment
metadata: { name: git-mcp, namespace: tools }
spec:
  template:
    metadata: { labels: { app.kubernetes.io/name: git-mcp } }
    spec:
      containers:
        - name: server
          image: ghcr.io/yourorg/git-mcp:latest
          env:
            - { name: PORT, value: "8080" }
            - { name: MODE, value: "read-only" }
            - { name: ALLOW_REPOS, value: "yirra/docs,yirra/shop,yirra/admin" }
            - { name: GIT_SSH_KEY_PATH, value: "/secrets/id_ed25519" }
            - { name: GIT_KNOWN_HOSTS, valueFrom: { secretKeyRef: { name: git-mcp-secrets, key: GIT_KNOWN_HOSTS } } }
          volumeMounts:
            - { name: ssh, mountPath: /secrets, readOnly: true }
      volumes:
        - name: ssh
          secret:
            secretName: git-mcp-secrets
            items:
              - { key: GIT_SSH_KEY, path: id_ed25519 }
```

### 4.4 DB MCP (always RO)

`overlays/prod/db/patch.deployment.yaml`

```yaml
apiVersion: apps/v1
kind: Deployment
metadata: { name: db-mcp, namespace: tools }
spec:
  template:
    metadata: { labels: { app.kubernetes.io/name: db-mcp } }
    spec:
      containers:
        - name: server
          image: ghcr.io/yourorg/postgres-mcp:latest
          env:
            - { name: PORT, value: "8080" }
            - { name: READ_ONLY, value: "true" }
            - { name: STATEMENT_TIMEOUT_MS, value: "8000" }
            - { name: MAX_ROWS, value: "5000" }
            - { name: DENY_DDL, value: "true" }
            - { name: DENY_MUTATION, value: "true" }
            - { name: DATABASE_URL, valueFrom: { secretKeyRef: { name: db-mcp-secrets, key: DATABASE_URL } } }
```

### 4.5 Fetch MCP

`overlays/prod/fetch/patch.deployment.yaml`

```yaml
apiVersion: apps/v1
kind: Deployment
metadata: { name: fetch-mcp, namespace: tools }
spec:
  template:
    metadata: { labels: { app.kubernetes.io/name: fetch-mcp } }
    spec:
      containers:
        - name: server
          image: ghcr.io/yourorg/fetch-mcp:latest
          env:
            - { name: PORT, value: "8080" }
            - { name: ALLOWLIST_REGEX, value: "^(https://(yirrasystems\\.com|app\\.yirrasystems\\.com|flows\\.addiaire\\.com))$" }
            - { name: MAX_BODY_BYTES, value: "1048576" }
            - { name: REQUEST_TIMEOUT_MS, value: "8000" }
            - { name: REDACT_HEADERS, value: "authorization,cookie" }
            - { name: HTML_TO_MD, value: "true" }
```

### 4.6 Stripe MCP (RO in prod)

`overlays/prod/stripe/patch.deployment.yaml`

```yaml
apiVersion: apps/v1
kind: Deployment
metadata: { name: stripe-mcp, namespace: tools }
spec:
  template:
    metadata: { labels: { app.kubernetes.io/name: stripe-mcp } }
    spec:
      containers:
        - name: server
          image: ghcr.io/yourorg/stripe-mcp:latest
          env:
            - { name: PORT, value: "8080" }
            - { name: MODE, value: "read-only" }
            - { name: STRIPE_API_KEY, valueFrom: { secretKeyRef: { name: stripe-mcp-secrets, key: STRIPE_API_KEY } } }
            - { name: REQUEST_TIMEOUT_MS, value: "10000" }
```

### 4.7 n8n MCP

`overlays/prod/n8n/configmap.tools.yaml`

```yaml
apiVersion: v1
kind: ConfigMap
metadata: { name: n8n-mcp-tools, namespace: tools }
data:
  tools.json: |
    {
      "workflows": [
        {"name":"approve_reddit","method":"POST","url":"https://flows.addiaire.com/webhook/reddit-approve"},
        {"name":"fulfill_order","method":"POST","url":"https://flows.addiaire.com/webhook/fulfill-order"},
        {"name":"notify_slack","method":"POST","url":"https://flows.addiaire.com/webhook/notify-slack"}
      ],
      "authHeader": "X-API-Key"
    }
```

`overlays/prod/n8n/patch.deployment.yaml`

```yaml
apiVersion: apps/v1
kind: Deployment
metadata: { name: n8n-mcp, namespace: tools }
spec:
  template:
    metadata: { labels: { app.kubernetes.io/name: n8n-mcp } }
    spec:
      containers:
        - name: server
          image: ghcr.io/yourorg/n8n-mcp:latest
          env:
            - { name: PORT, value: "8080" }
            - { name: N8N_API_KEY, valueFrom: { secretKeyRef: { name: n8n-mcp-secrets, key: N8N_API_KEY } } }
            - { name: REQUEST_TIMEOUT_MS, value: "15000" }
          volumeMounts:
            - { name: tools, mountPath: /app/tools.json, subPath: tools.json }
      volumes:
        - { name: tools, configMap: { name: n8n-mcp-tools } }
```

### 4.8 Aggregate prod overlay

`overlays/prod/kustomization.yaml`

```yaml
resources:
  - namespace.yaml
  - ../../cloudflared
  - pm
  - fs
  - git
  - db
  - fetch
  - stripe
  - n8n
```

---

## 5) Staging overlays

Mirror `overlays/prod` into `overlays/staging`:

* Namespace file uses `tools-staging`.
* **MODE** toggles to `"write"` for MCPs where you want writes (pm/fs/git/stripe with **test** key).
* Secrets point to staging values (DB URL, service tokens, Stripe **test** key).
* Cloudflared ConfigMap already includes your **single-word** staging hostnames.

---

## 6) Secrets (create out-of-band)

Create secrets at runtime (don’t commit real values to git):

```bash
# Namespace prod
kubectl create ns tools

# PM (prod)
kubectl -n tools create secret generic pm-mcp-secrets \
  --from-literal=PM_API_TOKEN='REDACTED'

# Git (prod)
kubectl -n tools create secret generic git-mcp-secrets \
  --from-file=GIT_SSH_KEY=./id_ed25519 \
  --from-literal=GIT_KNOWN_HOSTS='github.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAI...'

# DB (prod)
kubectl -n tools create secret generic db-mcp-secrets \
  --from-literal=DATABASE_URL='postgres://mcp_ro:***@pg-host:5432/ecom'

# Stripe (prod)
kubectl -n tools create secret generic stripe-mcp-secrets \
  --from-literal=STRIPE_API_KEY='sk_live_***'

# n8n (prod)
kubectl -n tools create secret generic n8n-mcp-secrets \
  --from-literal=N8N_API_KEY='***'
```

Repeat in `tools-staging` with staging values.

---

## 7) Apply

```bash
# PROD
kubectl apply -k MCP_server/overlays/prod
kubectl -n tools get deploy,svc,pods

# STAGING
kubectl apply -k MCP_server/overlays/staging
kubectl -n tools-staging get deploy,svc,pods
```

---

## 8) Cloudflare: DNS + Access

**DNS**

* For *each* hostname above, create a **CNAME** to your Tunnel’s `XXXXXXXX.cfargotunnel.com`, **Proxy = ON** (orange cloud).

**Access**

* Create a **Self-hosted** Access Application per hostname (prod & staging).
* Policy: your email/SSO group, or **Service Tokens** for headless tools.
* If using Service Tokens, your client must send:

  * `CF-Access-Client-Id: <id>`
  * `CF-Access-Client-Secret: <secret>`

---

## 9) Minimal NetworkPolicies (optional but recommended)

If you run default-deny egress, add these per namespace (`tools` and `tools-staging`):

```yaml
# Allow cloudflared → MCP pods (ingress)
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata: { name: allow-cloudflared-to-mcps, namespace: tools }
spec:
  podSelector: {}          # all MCP pods
  policyTypes: [Ingress]
  ingress:
  - from:
    - podSelector: { matchLabels: { app: cloudflared } }
    ports: [{ protocol: TCP, port: 80 }]

---
# Allow DNS egress for all pods
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata: { name: allow-dns-egress, namespace: tools }
spec:
  podSelector: {}
  policyTypes: [Egress]
  egress:
  - to:
    - namespaceSelector: { matchLabels: { kubernetes.io/metadata.name: kube-system } }
    ports:
      - { protocol: UDP, port: 53 }
      - { protocol: TCP, port: 53 }
```

(If Fetch/Stripe/PM adapters need external egress directly, add explicit allows to those domains or rely on the admin/n8n APIs they call over HTTPS.)

---

## 10) Client configuration (Cursor / Claude Desktop)

Example **prod**:

```json
{
  "mcpServers": {
    "pm":    { "transport": { "type": "sse", "url": "https://pm-mcp.yirrasystems.com" } },
    "fs":    { "transport": { "type": "sse", "url": "https://fs-mcp.yirrasystems.com" } },
    "git":   { "transport": { "type": "sse", "url": "https://git-mcp.yirrasystems.com" } },
    "db":    { "transport": { "type": "sse", "url": "https://db-mcp.yirrasystems.com" } },
    "fetch": { "transport": { "type": "sse", "url": "https://fetch-mcp.yirrasystems.com" } },
    "stripe":{ "transport": { "type": "sse", "url": "https://stripe-mcp.yirrasystems.com" } },
    "n8n":   { "transport": { "type": "sse", "url": "https://n8n-mcp.addiaire.com" } }
  }
}
```

If guarded by **Cloudflare Access Service Tokens**, add headers per server:

```json
"headers": {
  "CF-Access-Client-Id": "…",
  "CF-Access-Client-Secret": "…"
}
```

Add staging entries similarly for your `*-mcpstaging` hosts.

---

## 11) Health checks & smoke tests

Inside the cluster (bypass Cloudflare):

```bash
kubectl -n tools run tmp --rm -it --image=curlimages/curl -- \
  sh -c 'for s in pm-mcp fs-mcp git-mcp db-mcp fetch-mcp stripe-mcp n8n-mcp; do \
    echo "== $s =="; curl -fsS http://$s/healthz || true; echo; done'
```

Cloudflared routing:

```bash
kubectl -n tools logs deploy/cloudflared | tail -n 100
```

From your workstation (with Access headers if enabled):

```bash
curl -I https://pm-mcp.yirrasystems.com \
  -H "CF-Access-Client-Id: <id>" \
  -H "CF-Access-Client-Secret: <secret>"
```

Success criteria:

* `dig CNAME pm-mcp.yirrasystems.com` returns your `*.cfargotunnel.com`.
* All MCP Deployments `1/1 Running`.
* Cloudflared logs show each hostname route healthy.
* Prod MCPs accept **read** calls; **write** tools return `403 MCP_WRITE_DISABLED`.
* Staging MCPs perform writes where enabled.

---

## 12) Security & ops essentials

* **Prod = RO** everywhere:

  * `MODE=read-only` (pm/fs/git/stripe), `READ_ONLY=true` (db).
  * PM token scopes (prod): `projects:read,tasks:read,ai:plan` only.
* **Stripe**: live key only in prod RO; **test** key in staging.
* **Fetch**: keep allowlist strict:

  ```
  ALLOWLIST_REGEX="^(https://(yirrasystems\.com|app\.yirrasystems\.com|flows\.addiaire\.com))$"
  ```
* **Image pinning** (recommended):

  ```
  image: ghcr.io/yourorg/http-proxy-mcp@sha256:<digest>
  ```
* **Logs/metrics** (if supported by images):

  * `/metrics` scrape; alert on error rate >1% (5m), p95 >1.2s (5m), any `write_blocked_total > 0` in prod.
  * JSON logs with fields: `server,tool,method,path,status,ms,mode`.

---

## 13) Common pitfalls

* Using **A records** to origin IP instead of **CNAME** to the Tunnel.
* Cloudflared `ingress:` missing one hostname.
* Service name/namespace mismatch (`kubectl get svc` to confirm).
* Client blocked by Access (add Service Token headers).
* Service not listening on **port 80** at the Service level (fix Service `port: 80`).

---

## 14) Runbooks

**Redeploy an MCP**

```bash
kubectl -n tools rollout restart deploy/pm-mcp
kubectl -n tools get pods -w
```

**Rotate a secret**

```bash
kubectl -n tools delete secret pm-mcp-secrets
kubectl -n tools create secret generic pm-mcp-secrets --from-literal=PM_API_TOKEN='...'
kubectl -n tools rollout restart deploy/pm-mcp
```

**Add a new MCP**

1. Copy an overlay folder, set image/env/volumes.
2. Add hostname mapping in `cloudflared/configmap.yaml`.
3. Add CNAME in Cloudflare DNS to the Tunnel.
4. (Optional) Add Cloudflare Access app/policy.
5. `kubectl apply -k overlays/prod` (and/or staging).

---

That’s the complete, production-safe setup aligned to your domains and the single-word staging subdomains you chose.
